import time
import datetime
import random
import subprocess
import inspect
import os
from midiutil.MidiFile import MIDIFile

# set up file paths
filename = inspect.getframeinfo(inspect.currentframe()).filename
MAIN_PATH = os.path.dirname(os.path.abspath(filename)) + '/'
OUTPUT_FILE_PATH = MAIN_PATH + 'output_files/'
SAMPLES_PATH = MAIN_PATH + 'samples/'


class song():
    """Defines the song"""

    def __init__(self, rand_seed=None, tempo=None, divs_per_beat=None, beats_per_bar=None, key=None, structure=None):
        """Initializes properties of the song"""
        self.set_rand_seed(rand_seed) 
        self.name = datetime.datetime.fromtimestamp(time.time()).strftime('%Y_%m_%d__%H_%M_%S') + "_seed_" + str(self.rand_seed)
        self.track = 0
        self.time = 0
        self.tempo = tempo or random.randint(70,135)  # value is bpm
        self.divs_per_beat = divs_per_beat or 4  # default 1/4 notes
        self.beats_per_bar = beats_per_bar or 4  # default 4 beats per bar
        self.cur_channel = -1
        self.channel_sample_map = {}
        self.set_midi_obj()
        self.set_key(key)
        self.set_structure(structure)
        self.verse = verse(self, prev_part=None)
        self.chorus = chorus(self, prev_part=self.verse)
        self.gen_song()

    def get_channel(self):
        """Returns the midi channel for an instrument"""
        # get the next available midi channel. channel 9 is reserved for drums, so skip it
        if self.cur_channel == 8:
            self.cur_channel = 10
        else:
            self.cur_channel = self.cur_channel + 1
        return self.cur_channel

    def set_key(self, key):
        """Set the musical key of the song"""
        keys = music_theory.keys
        self.key = key or keys[random.randint(0,len(keys)-1)]

    def set_structure(self, structure=None):
        """Sets song structure, e.g. [verse, chorus, verse, verse, chorus]"""
        self.structure = structure or ['verse', 'verse', 'chorus', 'chorus','verse','verse','chorus','chorus','verse','verse','chorus','chorus']
      
    def set_rand_seed(self, rand_seed=None):
        """Sets the random seed for the song"""
        self.rand_seed = rand_seed or random.randint(0,100000000)
        random.seed(self.rand_seed)

    def set_midi_obj(self):
        """Sets the MIDIUtil midi object"""
        self.midi_obj = MIDIFile(1)
        self.midi_obj.addTrackName(self.track, self.time, self.name)
        self.midi_obj.addTempo(self.track, self.time, self.tempo * self.divs_per_beat)

    def gen_song(self):
        """Puts the parts of the song together"""
        start = 0
        # addNote below is a MIDIUtil function that adds a note to the midi file
        for part in self.structure:
            if part == 'verse':
                for note in self.verse.notes_list:
                    self.midi_obj.addNote(self.track,note['channel'],note['pitch'],note['time']+start,note['duration'],note['volume'])
                start = start + self.verse.bars * self.divs_per_beat * self.beats_per_bar
            if part == 'chorus':
                for note in self.chorus.notes_list:
                    self.midi_obj.addNote(self.track,note['channel'],note['pitch'],note['time']+start,note['duration'],note['volume'])
                start = start + self.chorus.bars * self.divs_per_beat * self.beats_per_bar
        # add some silent seconds to the end of the song
        blank_seconds = 4
        for i in range(int(self.divs_per_beat*(self.tempo/60.0)*blank_seconds)):
            self.midi_obj.addNote(self.track,0,0,i+start,1,0)

    def write_midi(self):
        """Writes the midi file generated by MIDIUtil"""
        binfile = open(OUTPUT_FILE_PATH.replace('\\', '') + self.name + ".mid", 'wb')
        self.midi_obj.writeFile(binfile)
        binfile.close()

    def write_fs_script(self):
        """Writes the FluidSynth script file"""
        f = open(OUTPUT_FILE_PATH.replace('\\', '') + self.name + ".txt", 'w')
        load = ''
        select = ''
        channel_sample_map_keys = self.channel_sample_map.keys()
        # generates lines of "load <sample file path>"
        for key in channel_sample_map_keys:
            line = 'load {}{}'.format(SAMPLES_PATH, self.channel_sample_map[key])
            load = load + line + '\n'
        # generates lines of "select <channel> <SoundFont number (in order loaded above)> <bank> <preset>"
        for i in range(len(channel_sample_map_keys)):
            key = channel_sample_map_keys[i]
            line = 'select {} {} {} {}'.format(key, i+1, 0, 0)
            select = select + line + '\n'      
        f.write(load + select + 'fonts \n' + 'channels \n')  # prompt SoundFonts and channel assignments to be displayed in terminal
        f.close()
   
    def play_audio_fs(self):
        """Plays the generated audio file with FluidSynth, and saves the midi file and FluidSynth script"""
        self.write_midi()
        self.write_fs_script()
        subprocess.call("fluidsynth " + OUTPUT_FILE_PATH + self.name + ".mid -f " + OUTPUT_FILE_PATH + self.name + ".txt -o player.reset-synth=FALSE -i", shell=True)

    def write_raw_audio(self):
        """Saves the .raw audio file and saves the midi file and FluidSynth script"""
        self.write_midi()
        self.write_fs_script()
        subprocess.call("fluidsynth " + OUTPUT_FILE_PATH + self.name + ".mid -f " + OUTPUT_FILE_PATH + self.name + ".txt -o player.reset-synth=FALSE -i -F " + OUTPUT_FILE_PATH + self.name + ".raw", shell=True)
        
    def convert_raw_to_wav(self):
        """Saves .wav version of the .raw audio file. Requires SoX, and the .raw file must exist"""
        subprocess.call("sox -b 16 -c 2 -s -r 44100 " + OUTPUT_FILE_PATH + self.name + ".raw " + OUTPUT_FILE_PATH + self.name + ".wav", shell=True)

  
class verse():
    """Defines a part of a song: a 'verse'"""
    
    def __init__(self, song, prev_part):
        """Initializes properties of the verse""" 
        self.song = song
        self.prev_part = prev_part
        self.notes_list = [] 
        self.set_bars()
        self.chords = []
        self.set_chords()
        self.set_rhythm()
        self.set_melody()
        self.set_drums()
        self.set_bass()

    def set_bars(self):
        """Sets the number of bars in the song part"""
        self.bars = 4

    def set_chords(self):
        """Sets the chords to be played in the song part"""
        self.chords = []
        for i in range(self.bars * self.song.beats_per_bar * self.song.divs_per_beat):  # for every note in the song part
            if i%(self.song.beats_per_bar * self.song.divs_per_beat) == 0:  # at the start of a bar
                chord = self.get_chord()
            self.chords.append(chord)
  
    def set_bass(self):
        """Adds bass notes to the list of notes for the song part"""
        note_volume = 100
        note_duration = self.song.beats_per_bar * self.song.divs_per_beat
        channel = self.song.get_channel()
        sample = self.get_bass_sample()
        self.song.channel_sample_map[channel] = sample
        self.bass_notes = []
        
        for i in range(self.bars * self.song.beats_per_bar * self.song.divs_per_beat):  # for every note in the song part
            if i%(self.song.beats_per_bar * self.song.divs_per_beat) == 0:  # at the start of a bar
                chord = self.chords[i]
                bass_note = self.get_chord_notes(chord)[0] - 24  # two octaves lower than the root of the chord
                self.bass_notes.append({'channel':channel,'pitch':bass_note,'time':i,'duration':note_duration,'volume':note_volume,'chord':chord,'sample':sample})

        self.notes_list = self.notes_list + self.bass_notes
     
    def get_bass_sample(self):
        """Returns the filename of the bass sample"""
        return 'Acoustic_Bass.sf2'
           
    def set_drums(self):
        """Adds drum notes to the list of notes for the song part"""
        note_volume = 60
        note_duration = .5 * self.song.divs_per_beat
        channel = 9  # drums have to be on channel 9
        sample = self.get_drum_sample()
        self.song.channel_sample_map[channel] = sample
        self.drum_notes = []
        self.drum_bars = 1
        self.drum_loop = []
        notes_per_beat = random.choice([2.0,4.0])
        
        for i in range(self.drum_bars * self.song.beats_per_bar * self.song.divs_per_beat):  # for every note in the drum part
            if i%(self.song.divs_per_beat / notes_per_beat) == 0:  # determines when to play a drum     
                chord = self.chords[i]  
                # randomly chosing what drum(s) to play 
                bass_play = random.randint(0,self.song.beats_per_bar * self.song.divs_per_beat/note_duration) > random.randrange(0,15)
                snare_play = random.randint(0,self.song.beats_per_bar * self.song.divs_per_beat/note_duration) > random.randrange(0,18)
                hat_play = random.randint(0,self.song.beats_per_bar * self.song.divs_per_beat/note_duration) > random.randrange(0,12)
            
                # the pitch values below are specific to the drum sample
                if bass_play:
                    self.drum_loop.append({'channel':channel,'pitch':36,'time':i,'duration':note_duration,'volume':note_volume,'chord':chord,'sample':sample})
                if hat_play:
                    self.drum_loop.append({'channel':channel,'pitch':42,'time':i,'duration':note_duration,'volume':note_volume,'chord':chord,'sample':sample})
                if snare_play:
                    self.drum_loop.append({'channel':channel,'pitch':37,'time':i,'duration':note_duration,'volume':note_volume,'chord':chord,'sample':sample})
        
        # copy the drum loop to the rest of the verse
        for i in range(self.bars/self.drum_bars):
            for j in self.drum_loop:
                k = j.copy()
                k['time'] = k['time'] + (i * self.song.beats_per_bar * self.song.divs_per_beat)
                self.drum_notes.append(k)
            
        self.notes_list = self.notes_list + self.drum_notes   

    def get_drum_sample(self):
        """Returns the filename of the drum sample"""
        return 'DrumsDouglasNaturalStudioKitV2.sf2'

    def set_rhythm(self):
        """Adds the rhythm notes to the list of notes for the song part"""
        volume = 80
        duration = 4 * self.song.divs_per_beat
        channel = self.song.get_channel()
        sample = self.get_rhythm_sample()
        self.song.channel_sample_map[channel] = sample
        self.rhythm_notes = []
        
        for i in range(self.bars * self.song.beats_per_bar * self.song.divs_per_beat):  # for every note in the song part
            if i%(self.song.beats_per_bar * self.song.divs_per_beat) == 0:  # at the start of a bar
                chord = self.chords[i]
                chord_notes = self.get_chord_notes(chord)
                for chord_note in chord_notes:
                    self.rhythm_notes.append({'channel':channel,'pitch':chord_note,'time':i,'duration':duration,'volume':volume,'chord':chord,'sample':sample})
            
        self.notes_list = self.notes_list + self.rhythm_notes
    
    def get_rhythm_sample(self):
        """Returns the filename of the rhythm sample"""
        return 'AJH_Piano.sf2'

    def set_melody(self):
        """Adds the melody notes to the list of notes for the song part"""
        melody_index = self.get_first_melody_index()
        volume = 100
        duration = 2 * self.song.divs_per_beat
        channel = self.song.get_channel()
        sample = self.get_melody_sample()
        self.song.channel_sample_map[channel] = sample
        self.melody_notes = []
        rest_thresh = random.randrange(20,50)/100.0  # percent of notes that should be rests
        notes_per_beat = 2
        
        for i in range(self.bars * self.song.beats_per_bar * self.song.divs_per_beat):  # for every note in the song part
            chord = self.chords[i]
            if i%(notes_per_beat) == 0:  # determines how often to play a melody note
                melody_note, melody_index = self.get_next_melody_note_and_index(melody_index)
                is_rest = random.random() > rest_thresh
                if not is_rest:
                    self.melody_notes.append({'channel':channel,'pitch':melody_note,'time':i,'duration':duration,'volume':volume,'chord':chord,'sample':sample})

        self.notes_list = self.notes_list + self.melody_notes

    def get_melody_sample(self):
        """Returns the filename of the melody sample"""
        return 'AJH_Piano.sf2'

    def get_first_melody_index(self):
        """Returns the melody_set index of the midi offset"""
        return random.randint(0,len(music_theory.melody_set)-1)

    def get_next_melody_note_and_index(self, melody_index):
        """Returns a midi value for the next melody note to play and the melody_set index of that note"""
        new_note_index = -1  # set index outside range of possible indexes
        while (new_note_index < 0) or (new_note_index > (len(music_theory.melody_set) - 1)):  # while the index of new note is not in range of possible indexes
            index_diff = random.randint(-1*1,1)  # pick the offset of the index of next note
            new_note_index = index_diff + melody_index
        new_note = music_theory.melody_set[new_note_index] + music_theory.melody_start_note_map[self.song.key]  # add offset to starting midi note
        return new_note, new_note_index

    def get_chord(self):
        """Returns a chord"""
        chords = music_theory.chords
        return chords[random.randint(0,len(chords)-1)]

    def get_chord_notes(self, chord):
        """Returns the midi values for notes of a given chord"""
        chord_notes = []
        for i in music_theory.chord_map[chord]:
            chord_notes.append(i + music_theory.chord_start_note_map[self.song.key])
        return chord_notes

    
class chorus(verse):
    """Defines a part of a song: a 'chorus'"""

    def __init__(self, song, prev_part):
        """Initializes properties of the chorus""" 
        self.song = song
        self.notes_list = []
        self.prev_part = prev_part
        self.set_bars()
        self.chords = []
        self.set_chords()
        self.set_rhythm()
        self.set_melody()
        self.set_bass()
        self.set_drums()

    def set_drums(self):
        """Adds drum notes to the list of notes for the song part"""
        self.drum_notes = []
        # the following uses the drum part from the previous song part
        for i in range(self.bars/self.prev_part.drum_bars):
            for j in self.prev_part.drum_loop:
                k = j.copy()
                k['time'] = k['time'] + (i*self.song.beats_per_bar*self.song.divs_per_beat)
                self.drum_notes.append(k)
                
        self.notes_list = self.notes_list + self.drum_notes


class music_theory():
    """Defines mappings between musical notes/chords and midi notes/offsets, and defines sets of possible notes/chords to play"""

    keys = ['A','Bb','B','C','Db','D','Eb','E','F','Gb','G','Ab']  # set of possible keys
    chord_start_note_map = {
        'A':45, 'Bb':46, 'B':47, 'C':48, 'Db':49, 'D':50, 'Eb':51, 'E':52, 
        'F':53, 'Gb':54, 'G':55, 'Ab':56}  # mapping to the root note of the key's I chord
    melody_start_note_map = {
        'A':81, 'Bb':82, 'B':83, 'C':72, 'Db':73, 'D':74, 'Eb':75, 'E':76, 
        'F':77, 'Gb':78, 'G':79, 'Ab':80}  # mapping to a reference note for melodies in that key
    melody_set = [-5, -3, 0, 2, 4, 7, 9, 12, 14, 16]  # offsets from melody_start_notes that lie on the Pentatonic scale
    chords = ['I', 'IM7', 'iim', 'iim7', 'iiim', 'iiim7', 'IV', 'IVM7', 'V', 'vim', 'vim7']  # set of possible chords to play
    chord_map = {
        'I':[0,4,7], 'IM7':[0,4,7,11], 'iim':[2,5,9], 'iim7':[2,5,9,12], 'iiim':[4,7,11], 
        'iiim7':[4,7,11,14], 'IV':[5,9,12], 'IVM7':[5,9,12,16], 'IVm':[5,8,12], 'IVm7':[5,8,12,16], 
        'V':[7,11,14], 'V7':[7,11,14,17], 'vim':[9,12,16], 'vim7':[9,12,16,19]}  # mapping to offsets from the chord_start_notes


